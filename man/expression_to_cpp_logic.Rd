% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expression_to_cpp.R
\name{expression_to_cpp_logic}
\alias{expression_to_cpp_logic}
\title{Convert R expressions to C++ style logical strings}
\usage{
expression_to_cpp_logic(expr, use_placeholders = TRUE)
}
\arguments{
\item{expr}{A quoted expression containing a boolean statement or a character
string that can be parsed to one. Inputs are not captured unevaluated, so
use `quote()` or `expression()` when supplying inline expressions.}

\item{use_placeholders}{Logical flag indicating whether non-operator
sub-expressions should be replaced by placeholders. When `FALSE`, the
original `deparse()`d expression is kept in the output string while the
placeholder mapping is still reported.}
}
\value{
A list with elements
* `expression`: the constructed C++ style logical expression string.
* `placeholders`: named character vector that maps placeholder names to the
  original expression strings.
* `order_variables`: named character vector that maps variable tokens (`n1`,
  `n2`, …) to the variable names used in comparisons.
}
\description{
The functions walk quoted R language objects (for example those produced by
`quote()`) or character strings and rewrite boolean operators to their C++
equivalents. Supported operators are `&&`, `||`, `xor()` and `!`. Sub-
expressions that are not one of these operators are replaced by stable
placeholders so that identical fragments share the same name. Logical
constants `TRUE` and `FALSE` are translated to lowercase `true` and `false`.
}
\details{
Comparisons using `<`, `>`, `<=`, `>=`, `==` and `!=` are rewritten into
dedicated ordering placeholders of the form `L_n1_n2`, `E_n1_n2` and
`G_n1_n2` (for "less", "equal" and "greater"). Each variable that appears in
a comparison receives a numbered token `n1`, `n2`, … and these tokens are
used to build the comparison placeholders. Compound comparisons such as
`<=`, `>=` and `!=` are translated into disjunctions of the basic placeholders.
The mapping of variable tokens is returned alongside other placeholders so
that downstream code can enforce ordering constraints.
}
\examples{
expression_to_cpp_logic(quote(((x && y) || f(z)) && w))

expression_to_cpp_logic("xor(x, y) || f(z) && w")

}
